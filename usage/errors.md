# Errors

AllFutures supports the same error handling pipeline as Active Record, `errors`, which is an enumerable instance of `ActiveModel::Errors`.

When validations fail, `ActiveModel::Error` instances will be added to the `errors.objects` Array. `objects` is actually just an alias for `errors.errors`, which is _just not pretty enough_ for Rails. :see\_no\_evil:

{% hint style="success" %}
In the interest of brevity and readability, the receiver and `errors` object have been omitted from every reference to a method in this chapter.

When you read `full_messages_for :name`, it is a stand-in for `record.errors.full_messages_for :name`.
{% endhint %}

When a model is initialized, its `objects` Array is empty until you either call `save` / `update` or invoke `valid?` directly. `valid?` returns `false` if at least one validation failed, and there will now be at least one `ActiveModel::Error` in the `objects` Array.

### Successful failure

The `valid?` method clears the `objects` Array, which means that **adding errors will not make a model invalid**. Instead, it's failed validations that typically add the errors.

```ruby
class Teenager < AllFutures::Base
  validate :designated_driver?

  def :designated_driver?
    errors.add(:base, "is drunk") unless sober?
  end
end

```

Our goal is to respond to this invalid state as part of the normal user experience, _without actually raising an application level exception_. To achieve this "successful failure", Rails gives us a family of methods that operate on the `objects` Array.&#x20;

Many Rails developers think of `errors` as "the thing generated resources use to show validation failure messages". AllFutures offers developers several compelling reasons to learn what `ActiveModel::Errors` has to offer someone building a reactive UI.

### So, you think you have some errors

Let's start with a basic assumption: if your model is `valid?` - that is, `true` - then you shouldn't have any errors.

However, you might not want to run `valid?` because it runs all of your validations again, and that might be undesirable. The [valid\_email2](https://github.com/lisinge/valid\_email2) gem actually tests for valid MX servers, which could be slow. Or perhaps your validations connect with a [paid API](https://github.com/stripe-samples/identity)? (**Don't** actually do this!)

You can use the `any?` method to check for the presence of errors in the `objects` Array, and `size` to get a count. You can use `attribute_names` to access an Array of Symbols representing - you guessed it - attribute names that have errors associated with them.

You can pass an attribute as a Symbol to `include?` (aliased as both `key?` and `has_key?`) and receive a Boolean response depending on whether that attribute has at least one error.

### Manipulating errors

`objects` is an Array, so you should be able to just add and remove Error objects, right?

Actually, no - we don't want to manually instantiate `ActiveModel::Error` objects. Instead, we can make use of [`add`](https://api.rubyonrails.org/v7.0.0/classes/ActiveModel/Errors.html#method-i-add) , [`delete`](https://api.rubyonrails.org/v7.0.0/classes/ActiveModel/Errors.html#method-i-delete) which make it easy to work with errors, even across multiple versions of Rails when the internal structure of `Error` objects might change over time.

You can `clear` your `objects` Array, but that doesn't make your model valid. To do that, you have to call `valid?` again and it will either persist your record or recreate the Array.

### `full_messages` vs `messages`

The error messages generated by `ActiveModel::Errors` are available with and without the attribute name prefixed, offering you a choice between "Name is invalid" (`full_messages`) and "is invalid" (`messages`).

Both are useful in different situations; you might not want an awkwardly-named attribute being converted into a proper noun, such as "State Province can't be empty".

The key to enlightenment is to spend time studying (and potentially modifying) [the locale file](https://github.com/rails/rails/blob/main/activemodel/lib/active\_model/locale/en.yml)s for the languages that you support. Of course, you can also [specify messages](https://guides.rubyonrails.org/active\_record\_validations.html#message) on a per-validation basis, but that can add complexity to your internationalization strategy.

### Working with `ActiveModel::Errors`

errors\[:attribute]

errors.messages\_for(:attribute) / errors.full\_messages\_for(:attribute)

errors.where(:name, :too\_short, minimum: 2)

errors.added? :name, "can't be blank"

errors.of\_kind?

